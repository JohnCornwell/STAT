#! /usr/bin/env python
#  -*- coding: utf-8 -*-
#
# GUI module generated by PAGE version 7.4
#  in conjunction with Tcl version 8.6
#    Jun 15, 2022 03:24:51 PM CDT  platform: Windows NT

import sys
import tkinter as tk
import tkinter.ttk as ttk
from tkinter import messagebox

from DataAccess import dataAccess
from GUI.Window import Window
from util import valid_int, valid_numeric
import globals
from GUI import autoScroll, statDemand, statResults, errorPopup


class DetailsWindow(Window):
    def __init__(self, top=None, previous=None, data=None, name=None):
        """This class configures and populates the toplevel Window.
           top is the toplevel containing Window."""
        _bgcolor = '#d9d9d9'  # X11 color: 'gray85'
        _fgcolor = '#000000'  # X11 color: 'black'
        _compcolor = 'gray40'  # X11 color: #666666
        _ana2color = 'beige'  # X11 color: #f5f5dc
        self.style = ttk.Style()
        if sys.platform == "win32":
            self.style.theme_use('winnative')
        self.style.configure('.', background=_bgcolor)
        self.style.configure('.', foreground=_fgcolor)
        self.style.map('.', background=[('selected', _compcolor), ('active', _ana2color)])

        self.top = top
        self.next = None
        self.previous = previous
        self.data = data
        self.name = name

        self.BaseFrame = tk.Frame(self.top)
        self.BaseFrame.place(relx=0.0, rely=0.0, relheight=1.0, relwidth=1.0)
        self.BaseFrame.configure(relief='groove')
        self.BaseFrame.configure(borderwidth="2")
        self.BaseFrame.configure(relief="groove")
        self.BaseFrame.configure(background="#000000")

        self.DetailsLabel = tk.Label(self.BaseFrame)
        self.DetailsLabel.place(relx=0.15, rely=0.076, height=40, relwidth=0.7)
        self.DetailsLabel.configure(background="#000000")
        self.DetailsLabel.configure(compound='left')
        self.DetailsLabel.configure(disabledforeground="#a3a3a3")
        self.DetailsLabel.configure(font="-family {Arial} -size 24")
        self.DetailsLabel.configure(foreground="#f2b83d")
        self.DetailsLabel.configure(text="{} Details".format(name))

        self.BackButton = tk.Button(self.BaseFrame)
        self.BackButton.place(relx=0.906, rely=0.289, height=44, width=107)
        self.BackButton.configure(activebackground="#f2b83d")
        self.BackButton.configure(activeforeground="#000000")
        self.BackButton.configure(background="#f2b83d")
        self.BackButton.configure(command=lambda: self.go_home())
        self.BackButton.configure(compound='center')
        self.BackButton.configure(disabledforeground="#a3a3a3")
        self.BackButton.configure(font="-family {Arial} -size 9")
        self.BackButton.configure(foreground="#000000")
        self.BackButton.configure(highlightbackground="#d9d9d9")
        self.BackButton.configure(highlightcolor="black")
        self.BackButton.configure(pady="0")
        self.BackButton.configure(text='''Back''')

        self.LoadButton = tk.Button(self.BaseFrame)
        self.LoadButton.place(relx=0.906, rely=0.198, height=44, width=107)
        self.LoadButton.configure(activebackground="#f2b83d")
        self.LoadButton.configure(activeforeground="#000000")
        self.LoadButton.configure(background="#f2b83d")
        self.LoadButton.configure(command=lambda: self.load_previous_run())
        self.LoadButton.configure(compound='center')
        self.LoadButton.configure(disabledforeground="#a3a3a3")
        self.LoadButton.configure(font="-family {Arial} -size 9")
        self.LoadButton.configure(foreground="#000000")
        self.LoadButton.configure(highlightbackground="#d9d9d9")
        self.LoadButton.configure(highlightcolor="black")
        self.LoadButton.configure(pady="0")
        self.LoadButton.configure(text='''Load''')

        self.UsernameLabel = tk.Label(self.BaseFrame)
        self.UsernameLabel.place(relx=0.68, rely=0.015, height=60, width=285)
        self.UsernameLabel.configure(anchor='nw')
        self.UsernameLabel.configure(background="#000000")
        self.UsernameLabel.configure(compound='left')
        self.UsernameLabel.configure(disabledforeground="#a3a3a3")
        self.UsernameLabel.configure(font="-family {Arial} -size 13")
        self.UsernameLabel.configure(foreground="#f2b83d")
        self.UsernameLabel.configure(text='''Logged in as: {}'''.format(globals.username))

        self.log_outButton = tk.Button(self.BaseFrame)
        self.log_outButton.place(relx=0.906, rely=0.015, height=44, width=107)
        self.log_outButton.configure(activebackground="#f2b83d")
        self.log_outButton.configure(activeforeground="#000000")
        self.log_outButton.configure(background="#f2b83d")
        self.log_outButton.configure(command=lambda: self.log_out())
        self.log_outButton.configure(compound='center')
        self.log_outButton.configure(disabledforeground="#a3a3a3")
        self.log_outButton.configure(font="-family {Arial} -size 9")
        self.log_outButton.configure(foreground="#000000")
        self.log_outButton.configure(highlightbackground="#d9d9d9")
        self.log_outButton.configure(highlightcolor="black")
        self.log_outButton.configure(pady="0")
        self.log_outButton.configure(text='''Log Out''')

        self.SwarmLabel = tk.Label(self.BaseFrame)
        self.SwarmLabel.place(relx=0.654, rely=0.228, height=21, width=154)
        self.SwarmLabel.configure(activebackground="#f9f9f9")
        self.SwarmLabel.configure(anchor='w')
        self.SwarmLabel.configure(background="#000000")
        self.SwarmLabel.configure(compound='left')
        self.SwarmLabel.configure(disabledforeground="#a3a3a3")
        self.SwarmLabel.configure(font="-family {Arial} -size 17")
        self.SwarmLabel.configure(foreground="#f2b83d")
        self.SwarmLabel.configure(highlightbackground="#d9d9d9")
        self.SwarmLabel.configure(highlightcolor="black")
        self.SwarmLabel.configure(text='''Swarm Details''')

        self.DemandLabel = tk.Label(self.BaseFrame)
        self.DemandLabel.place(relx=0.227, rely=0.228, height=21, width=171)
        self.DemandLabel.configure(activebackground="#f9f9f9")
        self.DemandLabel.configure(anchor='w')
        self.DemandLabel.configure(background="#000000")
        self.DemandLabel.configure(compound='left')
        self.DemandLabel.configure(disabledforeground="#a3a3a3")
        self.DemandLabel.configure(font="-family {Arial} -size 17")
        self.DemandLabel.configure(foreground="#f2b83d")
        self.DemandLabel.configure(highlightbackground="#d9d9d9")
        self.DemandLabel.configure(highlightcolor="black")
        self.DemandLabel.configure(text='''Demand Details''')

        self.ResultsButton = tk.Button(self.BaseFrame)
        self.ResultsButton.place(relx=0.906, rely=0.107, height=44, width=107)
        self.ResultsButton.configure(activebackground="#f2b83d")
        self.ResultsButton.configure(activeforeground="#000000")
        self.ResultsButton.configure(background="#f2b83d")
        self.ResultsButton.configure(command=lambda: self.view_run_results())
        self.ResultsButton.configure(compound='center')
        self.ResultsButton.configure(disabledforeground="#a3a3a3")
        self.ResultsButton.configure(font="-family {Arial} -size 9")
        self.ResultsButton.configure(foreground="#000000")
        self.ResultsButton.configure(highlightbackground="#d9d9d9")
        self.ResultsButton.configure(highlightcolor="black")
        self.ResultsButton.configure(pady="0")
        self.ResultsButton.configure(text='''View Results''')

        self.SwarmScroll = autoScroll.ScrolledText(self.BaseFrame)
        self.SwarmScroll.place(relx=0.555, rely=0.274, relheight=0.708, relwidth=0.32)
        self.SwarmScroll.configure(background="#f2b83d")
        self.SwarmScroll.configure(borderwidth="0")
        self.SwarmScroll.configure(font="-family {Courier} -size 13")
        self.SwarmScroll.configure(foreground="black")
        self.SwarmScroll.configure(highlightbackground="#d9d9d9")
        self.SwarmScroll.configure(highlightcolor="black")
        self.SwarmScroll.configure(insertbackground="black")
        self.SwarmScroll.configure(insertborderwidth="3")
        # the gold select will be white, and black background select will be gray
        self.SwarmScroll.configure(selectbackground="#ffffff")
        self.SwarmScroll.configure(selectforeground="black")
        self.SwarmScroll.configure(wrap="none")
        self.SwarmScroll.configure(spacing1=4)
        self.SwarmScroll.configure(spacing3=4)
        self.SwarmScroll.tag_configure("evenline", background="#000000", foreground="#f2b83d",
                                       selectbackground="#c4c4c4", selectforeground="black")

        self.DemandScroll = autoScroll.ScrolledText(self.BaseFrame)
        self.DemandScroll.place(relx=0.133, rely=0.274, relheight=0.709, relwidth=0.32)
        self.DemandScroll.configure(background="#f2b83d")
        self.DemandScroll.configure(font="-family {Courier} -size 13")
        self.DemandScroll.configure(foreground="black")
        self.DemandScroll.configure(highlightbackground="#d9d9d9")
        self.DemandScroll.configure(highlightcolor="black")
        self.DemandScroll.configure(insertbackground="black")
        self.DemandScroll.configure(insertborderwidth="3")
        self.DemandScroll.configure(selectforeground="black")
        self.DemandScroll.configure(wrap="none")
        self.DemandScroll.configure(spacing1=4)
        self.DemandScroll.configure(spacing3=4)
        # the gold select will be white, and black background select will be gray
        self.DemandScroll.configure(selectbackground="#ffffff")
        self.DemandScroll.tag_configure("oddline", background="#000000", foreground="#f2b83d",
                                        selectbackground="#c4c4c4", selectforeground="black")
        self.DemandScroll.tag_configure("title", justify="center", font=("Courier", 13, "bold"))

        # Get our data for the given test name
        # We rely on data access for validation of Num_tasks. The task and swarm windows will
        # populate data as possible and final validation happens when we submit
        error, values = dataAccess.load_test(self.name)
        if error != "":
            messagebox.showinfo(title="Error", message=error)
            self.destroy()
            return
        elif values is None:
            messagebox.showinfo(title="Error", message="No data was found for this test.")
        else:
            self.data = values
            self.fill_data()
            self.color()
        self.SwarmScroll.configure(state="disabled")
        self.DemandScroll.configure(state="disabled")

    def fill_data(self):
        error_list = list()
        error_list += self.use_demand()
        error_list += self.use_swarm()
        if len(error_list):
            errorPopup.ErrorGui(top=self.top, title="Error Reading Test Data", error_list=error_list)

    def use_demand(self):
        error_list = list()
        # get list of target profiles and related data for each profile
        if "Target_path" not in self.data or "Path_amplitude" not in self.data or "Path_period" not in self.data or \
                "Range" not in self.data or "Functions" not in self.data or "Num_tasks" not in self.data:
            error_list.append("Test file is missing task info.")
            return error_list
        try:
            num_tasks = int(self.data["Num_tasks"])
        except ValueError:
            error_list.append("Num_tasks value is not valid.")
            return error_list
        profiles = self.data["Target_path"].split(",")  # need to trim (might not be num_tasks profiles)
        amplitudes = self.data["Path_amplitude"].split(",")
        periods = self.data["Path_period"].split(",")
        ranges = self.data["Range"].split(",")
        functions = self.data["Functions"].split(",")
        value_list = ['square', 'positive_sine', 'sine', 'random', 'cycloid', 'positive_zig_zag',
                      'zig_zag', 'stair', 'trapezoid', 'custom']  # valid task profiles
        for task in range(0, num_tasks):
            self.DemandScroll.insert(tk.END, "Task {}:\n".format(task))
            if task < len(profiles) and profiles[task].strip(" \t") in value_list:
                task_profile = profiles[task].strip(" \t").replace("_", " ")
                self.DemandScroll.insert(tk.END, "Task Profile: " + task_profile + "\n")
            else:
                task_profile = None
                error_list.append("Task " + str(task) + " profile missing or invalid.")
            if task < len(ranges):
                try:
                    # check for value error
                    float(ranges[task])
                    self.DemandScroll.insert(tk.END, "Range:        " + ranges[task] + "\n")
                except ValueError:
                    error_list.append("Task " + str(task) + " has an invalid range.")
            else:
                error_list.append("Task " + str(task) + " has a missing range.")
            if task_profile is not None and task_profile == "custom":
                if len(functions) != 0:
                    self.DemandScroll.insert(tk.END, "Function:     " + functions.pop(0).strip(" \t") + "\n")
                else:
                    error_list.append("Task " + str(task) + " is missing its custom function.")
            else:
                # task is not custom and will need an amplitude (and possibly a period)
                if len(amplitudes) != 0:
                    try:
                        task_amplitude = float(amplitudes.pop(0))
                        self.DemandScroll.insert(tk.END, "Amplitude:    " + str(task_amplitude) + "\n")
                    except ValueError:
                        error_list.append("Task " + str(task) + " has an invalid amplitude.")
                else:
                    error_list.append("Task " + str(task) + " has a missing amplitude.")
                if task_profile is not None and task_profile not in ["random"] and len(periods) != 0:
                    try:
                        task_period = int(periods.pop(0))
                        self.DemandScroll.insert(tk.END, "Period:       " + str(task_period) + "\n")
                    except ValueError:
                        error_list.append("Task " + str(task) + " has an invalid period.")
                elif task_profile in ["random"]:
                    pass
                else:
                    error_list.append("Task " + str(task) + " has a missing period.")
        return error_list

    def use_swarm(self):
        error_list = list()
        if self.data.get("Pop_size") is not None and valid_int(self.data.get("Pop_size")):
            self.SwarmScroll.insert(tk.END, "Pop_size: ".ljust(22) + self.data.get("Pop_size") + "\n")
        else:
            error_list.append("Missing swarm population size.")
        if self.data.get("Thresh_init") is not None and valid_numeric(self.data.get("Thresh_init")):
            self.SwarmScroll.insert(tk.END, "Thresh_init: ".ljust(22) + self.data.get("Thresh_init") + "\n")
        else:
            error_list.append("Missing swarm threshold init.")
        if self.data.get("Prob_check") is not None and valid_numeric(self.data.get("Prob_check")):
            self.SwarmScroll.insert(tk.END, "Prob_check: ".ljust(22) + self.data.get("Prob_check") + "\n")
        else:
            error_list.append("Missing swarm prob check.")
        if self.data.get("Response_prob") is not None and valid_numeric(self.data.get("Response_prob")):
            self.SwarmScroll.insert(tk.END, "Response_prob: ".ljust(22) + self.data.get("Response_prob") + "\n")
        else:
            error_list.append("Missing swarm response probability.")
        if self.data.get("Task_selection") is not None:
            if self.data.get("Task_selection") == "random":
                self.SwarmScroll.insert(tk.END, "Task_selection:       Random\n")
            elif self.data.get("Task_selection") == "urgent":
                self.SwarmScroll.insert(tk.END, "Task_selection:       Urgent\n")
            else:
                error_list.append("Invalid swarm task selection.")
        else:
            error_list.append("Missing swarm task selection.")
        if self.data.get("Intensity_variation") is not None and valid_int(self.data.get("Intensity_variation")):
            if self.data.get("Intensity_variation") == "0":
                self.SwarmScroll.insert(tk.END, "Intensity_variation:  0\n")
            elif self.data.get("Intensity_variation") == "1":
                self.SwarmScroll.insert(tk.END, "Intensity_variation:  1\n")
            else:
                self.SwarmScroll.insert(tk.END, "Intensity_variation:  2\n")
        else:
            error_list.append("Missing swarm intensity variation.")
        if self.data.get("Intensity_aging_max") is not None and valid_numeric(self.data.get("Intensity_aging_max")):
            self.SwarmScroll.insert(tk.END, "Aging_max: ".ljust(22) + self.data.get("Intensity_aging_max") + "\n")
        else:
            error_list.append("Missing swarm intensity aging max.")
        if self.data.get("Intensity_aging_min") is not None and valid_numeric(self.data.get("Intensity_aging_min")):
            self.SwarmScroll.insert(tk.END, "Aging_min: ".ljust(22) + self.data.get("Intensity_aging_min") + "\n")
        else:
            error_list.append("Missing swarm intensity aging min.")
        if self.data.get("Intensity_aging_up") is not None and valid_numeric(self.data.get("Intensity_aging_up")):
            self.SwarmScroll.insert(tk.END, "Aging_up: ".ljust(22) + self.data.get("Intensity_aging_up") + "\n")
        else:
            error_list.append("Missing swarm intensity aging up.")
        if self.data.get("Intensity_aging_down") is not None and valid_numeric(self.data.get("Intensity_aging_down")):
            self.SwarmScroll.insert(tk.END, "Aging_down: ".ljust(22) + self.data.get("Intensity_aging_down") + "\n")
        else:
            error_list.append("Missing swarm intensity aging down.")
        if self.data.get("Kill_number") is not None and valid_int(self.data.get("Kill_number")):
            self.SwarmScroll.insert(tk.END, "Kill_number: ".ljust(22) + self.data.get("Kill_number") + "\n")
        else:
            error_list.append("Missing swarm kill number.")
        if self.data.get("First_extinction") is not None and valid_int(self.data.get("First_extinction")):
            self.SwarmScroll.insert(tk.END, "First_extinction: ".ljust(22) + self.data.get("First_extinction") + "\n")
        else:
            error_list.append("Missing swarm first extinction.")
        if self.data.get("Extinction_period") is not None and valid_int(self.data.get("Extinction_period")):
            self.SwarmScroll.insert(tk.END, "Extinction_period: ".ljust(22) + self.data.get("Extinction_period") + "\n")
        else:
            error_list.append("Missing swarm extinction period.")
        if self.data.get("Spontaneous_response_prob") is not None and \
                valid_numeric(self.data.get("Spontaneous_response_prob")):
            self.SwarmScroll.insert(tk.END, "Spontaneous_response: ".ljust(22) +
                                    self.data.get("Spontaneous_response_prob") + "\n")
        else:
            error_list.append("Missing swarm spontaneous response probability.")
        if self.data.get("Hetero_range_max") is not None and valid_numeric(self.data.get("Hetero_range_max")):
            self.SwarmScroll.insert(tk.END, "Hetero_range_max: ".ljust(22) + self.data.get("Hetero_range_max") + "\n")
        else:
            error_list.append("Missing swarm hetero range max.")
        if self.data.get("Hetero_range_min") is not None and valid_numeric(self.data.get("Hetero_range_min")):
            self.SwarmScroll.insert(tk.END, "Hetero_range_min: ".ljust(22) + self.data.get("Hetero_range_min") + "\n")
        else:
            error_list.append("Missing swarm hetero range min.")
        if self.data.get("Hetero_radius_max") is not None and valid_numeric(self.data.get("Hetero_radius_max")):
            self.SwarmScroll.insert(tk.END, "Hetero_radius_max: ".ljust(22) + self.data.get("Hetero_radius_max") + "\n")
        else:
            error_list.append("Missing swarm hetero radius max.")
        if self.data.get("Hetero_radius_min") is not None and valid_numeric(self.data.get("Hetero_radius_min")):
            self.SwarmScroll.insert(tk.END, "Hetero_radius_min: ".ljust(22) + self.data.get("Hetero_radius_min") + "\n")
        else:
            error_list.append("Missing swarm hetero radius min.")
        if self.data.get("RP_gaussian_mu") is not None and valid_numeric(self.data.get("RP_gaussian_mu")):
            self.SwarmScroll.insert(tk.END, "RP_gaussian_mu: ".ljust(22) + self.data.get("RP_gaussian_mu") + "\n")
        else:
            error_list.append("Missing swarm rp gaussian mu.")
        if self.data.get("RP_gaussian_std") is not None and valid_numeric(self.data.get("RP_gaussian_std")):
            self.SwarmScroll.insert(tk.END, "RP_gaussian_std: ".ljust(22) + self.data.get("RP_gaussian_std") + "\n")
        else:
            error_list.append("Missing swarm rp gaussian std.")
        if self.data.get("Thresh_dynamic") is not None and valid_int(self.data.get("Thresh_dynamic")):
            if self.data.get("Thresh_dynamic") == "0":
                self.SwarmScroll.insert(tk.END, "Thresh_dynamic:       0\n")
            elif self.data.get("Thresh_dynamic") == "1":
                self.SwarmScroll.insert(tk.END, "Thresh_dynamic:       1\n")
            elif self.data.get("Thresh_dynamic") == "2":
                self.SwarmScroll.insert(tk.END, "Thresh_dynamic:       2\n")
            elif self.data.get("Thresh_dynamic") == "3":
                self.SwarmScroll.insert(tk.END, "Thresh_dynamic:       3\n")
            else:
                error_list.append("Invalid swarm threshold dynamic.")
        else:
            error_list.append("Missing swarm threshold dynamic.")
        if self.data.get("Thresh_dynamic_init") is not None and valid_int(self.data.get("Thresh_dynamic_init")):
            if self.data.get("Thresh_dynamic_init") == "0":
                self.SwarmScroll.insert(tk.END, "Thresh_dynamic_init:  0\n")
            elif self.data.get("Thresh_dynamic_init") == "1":
                self.SwarmScroll.insert(tk.END, "Thresh_dynamic_init:  1\n")
            elif self.data.get("Thresh_dynamic_init") == "2":
                self.SwarmScroll.insert(tk.END, "Thresh_dynamic_init:  2\n")
            else:
                error_list.append("Invalid swarm threshold dynamic init.")
        else:
            error_list.append("Missing swarm threshold dynamic init.")
        if self.data.get("Thresh_increase") is not None and valid_numeric(self.data.get("Thresh_increase")):
            self.SwarmScroll.insert(tk.END, "Thresh_increase: ".ljust(22) + self.data.get("Thresh_increase") + "\n")
        else:
            error_list.append("Missing swarm threshold increase.")
        if self.data.get("Thresh_decrease") is not None and valid_numeric(self.data.get("Thresh_decrease")):
            self.SwarmScroll.insert(tk.END, "Thresh_decrease: ".ljust(22) + self.data.get("Thresh_decrease") + "\n")
        else:
            error_list.append("Missing swarm threshold decrease.")
        return error_list

    def color(self):
        # get the number of lines, and tag every even line
        end = int(self.DemandScroll.index('end-1c').split('.')[0])
        tag = "oddline"
        for i in range(end):
            if len(self.DemandScroll.get("{}.0".format(i), "{}.0 wordstart".format(i + 1))) < 10 and "Task" in \
                    self.DemandScroll.get("{}.0".format(i), "{}.0 wordstart".format(i + 1)):
                if tag == "oddline":
                    tag = "evenline"
                else:
                    tag = "oddline"
                # tag line as title line
                self.DemandScroll.tag_add("title", "{}.0".format(i), "{}.0 wordstart".format(i + 1))
            self.DemandScroll.tag_add(tag, "{}.0".format(i), "{}.0 wordstart".format(i + 1))
        end = int(self.SwarmScroll.index('end-1c').split('.')[0])
        for i in range(end):
            if i % 2 == 0:
                self.SwarmScroll.tag_add("evenline", "{}.0".format(i), "{}.0 wordstart".format(i + 1))

    def go_home(self):
        self.BaseFrame.destroy()
        self.next = None
        del self

    def load_previous_run(self):
        numTasks = 1
        try:
            numTasks = int(self.data.get("Num_tasks"))
        except ValueError:
            # use default of one task
            pass
        self.next = statDemand.DemandGui(top=self.top, previous=self, home=self.previous, data=self.data,
                                         num_tasks=numTasks)
        self.destroy()

    def log_out(self):
        self.BaseFrame.destroy()
        self.next = None
        self.previous.log_out()
        del self

    def destroy(self):
        self.BaseFrame.destroy()
        del self

    def view_run_results(self):
        self.next = statResults.ResultGui(top=self.top, home=self.previous, previous=self, name=self.name)
